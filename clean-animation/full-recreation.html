<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Full Sphere Cluster Recreation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    body {
      width: 100%;
      height: 100vh;
      overflow: hidden;
      background: #141515;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="info">
    Full Recreation with Neighbor Tracking<br>
    Spheres: <span id="count">0</span><br>
    FPS: <span id="fps">0</span>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ============================================================================
    // VERTEX SHADER - Exact from original
    // ============================================================================
    const vertexShader = `
      attribute vec3 position;
      attribute vec3 normal;
      attribute vec2 uv;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform mat4 modelMatrix;
      uniform mat3 normalMatrix;
      uniform vec3 cameraPosition;

      uniform vec3 u_lightPosition;
      uniform vec4 u_selfPositionRadius;
      uniform vec4 u_selfRotation;

      varying vec3 v_viewPosition;
      varying vec3 v_worldPosition;
      varying vec3 v_viewNormal;
      varying vec3 v_smoothViewNormal;
      varying vec2 v_uv;
      varying vec3 v_localPosition;
      varying float v_ao;
      varying float v_selfShadow;

      vec3 qrotate(vec3 v, vec4 q) {
        return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
      }

      void main() {
        v_localPosition = position;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        vec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;

        // Calculate self-shadowing from light
        vec4 invertedQuat = vec4(-u_selfRotation.xyz, u_selfRotation.w);
        vec3 L = (u_lightPosition - worldPosition) / u_selfPositionRadius.w;
        L = normalize(qrotate(L, invertedQuat));

        // Simple AO/shadow calculation
        vec3 absDir = abs(L);
        float selfShadow = (absDir.x + absDir.y + absDir.z) / 3.0;
        selfShadow = min(pow(selfShadow * 3.0, 0.3) * 1.45, 1.0);

        v_worldPosition = worldPosition;
        v_viewNormal = normalMatrix * normal;
        v_smoothViewNormal = normalMatrix * normal;
        v_viewPosition = -mvPosition.xyz;
        v_uv = uv;
        v_ao = 1.0;
        v_selfShadow = selfShadow;
      }
    `;

    // ============================================================================
    // FRAGMENT SHADER - With neighbor tracking
    // ============================================================================
    const fragmentShader = `
      #define NEIGHBOUR_COUNT 49

      precision highp float;

      varying vec3 v_viewNormal;
      varying vec3 v_smoothViewNormal;
      varying vec3 v_viewPosition;
      varying vec3 v_worldPosition;
      varying vec2 v_uv;
      varying vec3 v_localPosition;
      varying float v_ao;
      varying float v_selfShadow;

      uniform vec4 u_nearPositionRadiusList[NEIGHBOUR_COUNT];
      uniform vec3 u_nearColorList[NEIGHBOUR_COUNT];
      uniform vec2 u_nearTransparencyLumaList[NEIGHBOUR_COUNT];

      uniform float u_roughness;
      uniform vec3 u_bgColor;
      uniform vec3 u_color;
      uniform vec3 u_lightPosition;
      uniform vec3 cameraPosition;

      const float PI = 3.14159265359;

      vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {
        return normalize((vec4(dir, 0.0) * matrix).xyz);
      }

      // Simplified neighbor AO/GI calculation
      float calculateNeighborAO(vec3 worldPos, vec3 normal, vec4 nearPosRadius) {
        vec3 toNeighbor = nearPosRadius.xyz - worldPos;
        float dist = length(toNeighbor);
        float radius = nearPosRadius.w;

        // Simple sphere AO
        if (dist < radius * 2.5) {
          vec3 dir = normalize(toNeighbor);
          float alignment = max(0.0, -dot(normal, dir));
          float falloff = 1.0 - smoothstep(radius * 0.5, radius * 2.5, dist);
          return 1.0 - (alignment * falloff * 0.5);
        }
        return 1.0;
      }

      vec3 calculateNeighborGI(vec3 worldPos, vec4 nearPosRadius, vec3 nearColor, float nearLuma) {
        vec3 toNeighbor = nearPosRadius.xyz - worldPos;
        float dist = length(toNeighbor);
        float radius = nearPosRadius.w;

        // Color bleeding from nearby spheres
        if (dist < radius * 3.0) {
          float falloff = 1.0 - smoothstep(radius, radius * 3.0, dist);
          return nearColor * falloff * (1.0 - nearLuma * 0.5) * 0.3;
        }
        return vec3(0.0);
      }

      void main() {
        vec3 viewNormal = normalize(v_viewNormal);
        vec3 V = normalize(cameraPosition - v_worldPosition);
        vec3 N = normalize(v_viewNormal);
        vec3 L = normalize(u_lightPosition - v_worldPosition);

        float NdL = max(dot(N, L), 0.0);
        float NdV = max(dot(N, V), 0.0);

        // ========================================================================
        // NEIGHBOR-BASED AO AND GI (KEY FEATURE!)
        // ========================================================================
        float ao = 1.0;
        float shadow = 1.0;
        vec3 gi = vec3(0.0);

        // Process all neighbors
        for (int i = 0; i < NEIGHBOUR_COUNT; i++) {
          vec3 nearColor = u_nearColorList[i];
          vec2 nearTransparencyLuma = u_nearTransparencyLumaList[i];
          vec4 nearPosRadius = u_nearPositionRadiusList[i];

          // Calculate AO from this neighbor
          float neighborAO = calculateNeighborAO(v_worldPosition, N, nearPosRadius);
          ao *= neighborAO;

          // Calculate GI (color bleeding) from this neighbor
          vec3 neighborGI = calculateNeighborGI(v_worldPosition, nearPosRadius, nearColor, nearTransparencyLuma.y);
          gi += neighborGI;
        }

        // Normalize GI
        gi /= float(NEIGHBOUR_COUNT);
        gi *= 3.0; // Boost GI strength

        // ========================================================================
        // LIGHTING
        // ========================================================================
        vec3 ambient = u_bgColor * 0.3;
        vec3 diffuse = u_color * NdL;

        // Add self-shadow
        diffuse *= v_selfShadow;

        // Specular (simple Phong)
        vec3 R = reflect(-L, N);
        float spec = pow(max(dot(R, V), 0.0), mix(5.0, 50.0, 1.0 - u_roughness));
        vec3 specular = vec3(spec) * (1.0 - u_roughness);

        // Fresnel
        float fresnel = pow(1.0 - NdV, 3.0) * 0.3;

        // ========================================================================
        // FINAL COLOR with neighbor-based lighting
        // ========================================================================
        vec3 color = ambient + diffuse + specular + fresnel;
        color *= ao * v_ao; // Apply AO
        color += gi; // Add global illumination from neighbors
        color *= shadow;

        // Tone mapping
        color = color / (color + vec3(1.0));
        color = pow(color, vec3(1.0/2.2)); // Gamma correction

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // ============================================================================
    // SCENE SETUP
    // ============================================================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x141515);

    const camera = new THREE.PerspectiveCamera(
      25,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 17.5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ============================================================================
    // SPHERE CONFIGURATION - Using 50 for better clustering
    // ============================================================================
    const NUM_SPHERES = 50;
    const NEIGHBOUR_COUNT = NUM_SPHERES - 1;

    // Color palette
    const COLORS = ["#061dfb", "#ADFF00", "#f6000e", "#7e09f5", "#ffc000"];
    const selectedColor = COLORS[Math.floor(Math.random() * COLORS.length)];

    // Seeded random for consistent positions
    let seed = 12345;
    function seededRandom() {
      seed = (seed * 9301 + 49297) % 233280;
      return seed / 233280;
    }

    // ============================================================================
    // PHYSICS BODIES
    // ============================================================================
    class PhysicsBody {
      constructor(radius = 1.0, isFarBack = false) {
        this.radius = radius * 1.05;
        this.position = new THREE.Vector3(
          (seededRandom() - 0.5) * 12,
          (seededRandom() - 0.5) * 12,
          isFarBack ? 7 + seededRandom() : (seededRandom() - 0.5) * 6
        );
        this.velocity = this.position.clone().multiplyScalar(-2);
        this.quaternion = new THREE.Quaternion();
        this.angularVelocity = new THREE.Vector3();

        this.density = 1.0;
        this.mass = this.radius * this.radius * this.radius * this.density;
        this.inertia = this.mass * this.radius * this.radius * 0.4;
        this.friction = 2.0;
        this.frictionTot = 0;
        this.restitution = 0.8;
      }

      updateGravity(dt) {
        const GRAVITY_FACTOR = 40;
        const gravityForce = this.position.clone().negate().multiplyScalar(GRAVITY_FACTOR);
        const gravityAcc = gravityForce.multiplyScalar(1 / this.mass);
        gravityAcc.multiplyScalar(1 / (1 + this.frictionTot));

        this.velocity.addScaledVector(gravityAcc, dt);
        this.frictionTot *= 0.5;
      }

      update(dt) {
        this.position.addScaledVector(this.velocity, dt);
        this.velocity.multiplyScalar(Math.pow(0.2, dt));

        // Update rotation
        const angularSpeed = this.angularVelocity.length();
        if (angularSpeed > 0) {
          const axis = this.angularVelocity.clone().normalize();
          const deltaQ = new THREE.Quaternion().setFromAxisAngle(axis, angularSpeed * dt);
          this.quaternion.premultiply(deltaQ);
        }
      }
    }

    // ============================================================================
    // CREATE SPHERES with NEIGHBOR TRACKING
    // ============================================================================
    const physicsBodies = [];
    const sphereMeshes = [];
    const geometry = new THREE.SphereGeometry(1, 32, 32);

    // Create sphere configurations
    const sphereConfigs = [];
    for (let i = 0; i < NUM_SPHERES; i++) {
      const isFarBack = i >= NUM_SPHERES - 2; // Last 2 are far back
      const isColored = i % 3 === 0;
      const isWhite = i % 3 === 1;
      const isGlossy = i % 2 === 0;

      sphereConfigs.push({
        color: isColored ? selectedColor : (isWhite ? '#ffffff' : '#111111'),
        roughness: isGlossy ? 0.1 : 0.8,
        isColored: isColored,
        isFarBack: isFarBack
      });
    }

    // Create physics and meshes
    for (let i = 0; i < NUM_SPHERES; i++) {
      const config = sphereConfigs[i];
      const body = new PhysicsBody(1.0, config.isFarBack);
      physicsBodies.push(body);

      // Create shader material with neighbor tracking
      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          // Self uniforms
          u_color: { value: new THREE.Color(config.color) },
          u_bgColor: { value: new THREE.Color(0x141515) },
          u_lightPosition: { value: new THREE.Vector3(10, 10, 5) },
          u_roughness: { value: config.roughness },
          u_selfPositionRadius: { value: new THREE.Vector4(0, 0, 0, body.radius) },
          u_selfRotation: { value: new THREE.Vector4(0, 0, 0, 1) },

          // Neighbor arrays - THE KEY FEATURE!
          u_nearPositionRadiusList: { value: Array.from({ length: NEIGHBOUR_COUNT }, () => new THREE.Vector4()) },
          u_nearColorList: { value: Array.from({ length: NEIGHBOUR_COUNT }, () => new THREE.Color()) },
          u_nearTransparencyLumaList: { value: Array.from({ length: NEIGHBOUR_COUNT }, () => new THREE.Vector2()) }
        },
        defines: {
          NEIGHBOUR_COUNT: NEIGHBOUR_COUNT
        }
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.scale.setScalar(body.radius);
      mesh.userData.body = body;
      mesh.userData.config = config;
      mesh.userData.index = i;

      scene.add(mesh);
      sphereMeshes.push(mesh);
    }

    document.getElementById('count').textContent = NUM_SPHERES;

    // ============================================================================
    // PHYSICS SIMULATION
    // ============================================================================
    function updatePhysics(dt) {
      // Update gravity and physics
      for (let i = 0; i < physicsBodies.length; i++) {
        physicsBodies[i].updateGravity(dt);
      }

      // Collision detection
      for (let i = 0; i < physicsBodies.length; i++) {
        const body1 = physicsBodies[i];

        for (let j = i + 1; j < physicsBodies.length; j++) {
          const body2 = physicsBodies[j];

          const delta = body1.position.clone().sub(body2.position);
          const dist = delta.length();
          const minDist = body1.radius + body2.radius;

          if (dist < minDist) {
            // Collision response
            const normal = delta.normalize();
            const overlap = minDist - dist;

            body1.position.addScaledVector(normal, overlap * 0.5);
            body2.position.addScaledVector(normal, -overlap * 0.5);

            // Velocity response
            const relVel = body1.velocity.clone().sub(body2.velocity);
            const velAlongNormal = relVel.dot(normal);

            if (velAlongNormal < 0) {
              const e = (body1.restitution + body2.restitution) * 0.5;
              const j = -(1 + e) * velAlongNormal / (1 / body1.mass + 1 / body2.mass);

              const impulse = normal.multiplyScalar(j);
              body1.velocity.addScaledVector(impulse, 1 / body1.mass);
              body2.velocity.addScaledVector(impulse, -1 / body2.mass);
            }

            // Friction
            const combinedFriction = Math.sqrt(body1.friction * body2.friction);
            body1.frictionTot += combinedFriction;
            body2.frictionTot += combinedFriction;
          }
        }
      }

      // Update positions
      for (let i = 0; i < physicsBodies.length; i++) {
        physicsBodies[i].update(dt);
      }
    }

    // ============================================================================
    // UPDATE NEIGHBOR DATA - Critical for lighting!
    // ============================================================================
    function updateNeighborData() {
      for (let i = 0; i < sphereMeshes.length; i++) {
        const mesh = sphereMeshes[i];
        const body = mesh.userData.body;
        const uniforms = mesh.material.uniforms;

        // Update self data
        uniforms.u_selfPositionRadius.value.set(
          body.position.x,
          body.position.y,
          body.position.z,
          body.radius
        );
        uniforms.u_selfRotation.value.set(
          body.quaternion.x,
          body.quaternion.y,
          body.quaternion.z,
          body.quaternion.w
        );

        // Sort neighbors by distance
        const neighbors = [];
        for (let j = 0; j < sphereMeshes.length; j++) {
          if (i !== j) {
            const otherBody = sphereMeshes[j].userData.body;
            const dist = body.position.distanceToSquared(otherBody.position);
            neighbors.push({ index: j, dist });
          }
        }
        neighbors.sort((a, b) => a.dist - b.dist);

        // Update neighbor uniforms
        for (let n = 0; n < NEIGHBOUR_COUNT; n++) {
          const neighborIdx = neighbors[n].index;
          const neighborMesh = sphereMeshes[neighborIdx];
          const neighborBody = neighborMesh.userData.body;
          const neighborConfig = neighborMesh.userData.config;

          // Position + radius
          uniforms.u_nearPositionRadiusList.value[n].set(
            neighborBody.position.x,
            neighborBody.position.y,
            neighborBody.position.z,
            neighborBody.radius
          );

          // Color
          const color = new THREE.Color(neighborConfig.color);
          uniforms.u_nearColorList.value[n].copy(color);

          // Transparency + Luminance
          const luma = color.r * 0.299 + color.g * 0.587 + color.b * 0.114;
          uniforms.u_nearTransparencyLumaList.value[n].set(0, luma);
        }
      }
    }

    // ============================================================================
    // UPDATE MESH TRANSFORMS
    // ============================================================================
    function updateMeshTransforms() {
      for (let i = 0; i < sphereMeshes.length; i++) {
        const mesh = sphereMeshes[i];
        const body = mesh.userData.body;

        mesh.position.copy(body.position);
        mesh.quaternion.copy(body.quaternion);
      }
    }

    // ============================================================================
    // ANIMATION LOOP
    // ============================================================================
    let lastTime = performance.now();
    let frameCount = 0;
    let fpsTime = 0;

    function animate() {
      requestAnimationFrame(animate);

      const currentTime = performance.now();
      const deltaTime = Math.min((currentTime - lastTime) * 0.001, 0.033); // Cap at 30fps
      lastTime = currentTime;

      // Update FPS
      frameCount++;
      fpsTime += deltaTime;
      if (fpsTime >= 1.0) {
        document.getElementById('fps').textContent = frameCount;
        frameCount = 0;
        fpsTime = 0;
      }

      // Physics
      updatePhysics(deltaTime);

      // Update mesh positions
      updateMeshTransforms();

      // Update neighbor data - CRITICAL for lighting!
      updateNeighborData();

      // Render
      renderer.render(scene, camera);
    }

    // ============================================================================
    // WINDOW RESIZE
    // ============================================================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start animation
    animate();

    console.log('✓ Full recreation with neighbor tracking system loaded!');
    console.log(`✓ ${NUM_SPHERES} spheres with ${NEIGHBOUR_COUNT} neighbors each`);
  </script>
</body>
</html>
